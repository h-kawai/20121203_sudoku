いろいろなメモ：


sudoku2:

(0) sudoku2の最適化のテーマは「常識的な最適化」です。

(1)

あちこちに現れる if (BoardSize == 9) の条件分岐は、BoardSizeが定数なので、コンパイル時に
不要なほうは消え去り、条件分岐命令も生成されません。条件コンパイルの代わりになっています。


sudoku3:

(0) sudoku3の最適化のテーマは「C++の範囲でやれることは全部やる」です。


sudoku4:

(0) sudoku4の最適化のテーマは「無制限」です。とにかく速くするためにならなんでもしよう、と。

(1)

まず、このプログラムが一部の環境ではmakeできないという報告がありました。問題になっているのは、
count9as.nasのアセンブルです。・・・どうやらDEP（データ実行プロテクション）を有効にして
いると何もメッセージを出さずに終了してしまうようです。このアセンブラはその辺のことを考慮
しなくてもよかった時代の産物なので、対応できてなくてすみません。・・・その他の原因でも、
もしかしたらうまく動かない場合もあるかもしれません。そういう場合もあるので、その場合は
とりあえずあきらめてください。efg01もnaskもオープンソースソフトウェアで原則無保証なので、
行き届かないことがあっても仕方ないのです。すみません。

アセンブル結果はcount9as.objのとおりなので、これを使えばアセンブルが出来なくても問題ないと
思います。またここで使っているnaskというアセンブラはNASMの記法にかなり近いので、最初の
数行をコメントアウトすれば、おそらくNASMでもアセンブルできるのではないかと思われます。

それなら最初から世間でよく知られたNASMを使えばいいじゃないかという話になるわけですが、
私としては自分の使い慣れたものを使っているだけです。私としては高速に動作するsudoku4.exeを
提供することが目的で、これが普通のWindowsで問題なく動けばそれでよく、その開発ツールまでが
みなさんの環境で動作するかまでは気を配っていません。ソースの公開も隠す必要がないから公開
しているだけで、（C++部分についても）みなさんの環境ではビルドできずに役立たずかもしれません。

(2)

なぜアセンブラ化によって高速化できたのかということを説明します。

アセンブラではレジスタの使い方を細かく制御できるので、関数呼び出し時のオーバーヘッドなどを
ある程度削減できています。引数は基本的にレジスタ渡しになっています。
また主要な変数はすべてレジスタ化しました。レジスタの持ち替えみたいなコードもほとんど
なくなるように気を配りました。
これにより、board[]の読み込み以外ではほとんどメモリアクセスしないコードになっています。

またコードのアラインも細かく制御できるので、最適（と思われる）配置になるように、細かく
指定しています。

(3)

_count9AsmはC++からの入り口で、処理の本体の関数ではありません。subsubが本体で、これがC++
でいうところのcount()とcheckCell()に相当しています。

subsubは次のような初期値を持って呼び出すことになっています。この初期値の設定が_count9Asm
の仕事です。

    ESI = &board[0]
    EBX = i (探し始めの位置, 0〜80)
    EDI = n
    [EBP+0] = this
    [EBP+4] = &n

    EAX,ECX,EDXの値は破壊されます。
    EBX,ESP,EBP,ESIの値は破壊されません。
    EDIには結果が入ります。

count()が再帰関数だったので、アセンブラ化に伴いそれをJMPなどで最適化していると思われるかも
しれませんが、実はそんなことはしていません。subsubへ分岐する命令はすべてCALL命令で、つまり
末尾再帰のループ化などはしていないのです（というか末尾再帰ではないのできなかった）。

あちこちにfinへの分岐命令がありますが、これはRET命令に分岐しているだけです。RET命令は
関数内に一つだけにしておいたほうがどうやら高速のようだったので、そのようにしました。

できるだけasmの処理を再現するように、処理手順をC++風に書いてみます。

int i, n, *board, EAX; /* レジスタを外部変数として表現 */

void subsub(void)
{
    if (i >= BoardSize * BoardSize) { /* 空きがすべて埋まった！ */
        if (n >= 0) {
            nの値を[EBP+4]を使って書き戻す
            _storeResultAndTestLimit(this);
            n++;
        }
        return;
    }
    if (board[i] != 0) { i++; subsub(); i--; } /* 最終的にiの値を元に戻す必要があるので、再帰化した */
    switch (i) { （中略） } /* JMP  DWORD [table+EBX*4] */
caseend:
    EAXに結果を集約
    EAX ^= 0x1ff;
    if (EAX == 0) return;
    i++;
loop0:
    do {
        EAX & (-EAX) を計算 -> その値を board[i - 1] に書き込む
        /* x & (-x) を計算すると、xの中の高速なビット検索ができる */
        /* 参考: http://www.nminoru.jp/~nminoru/programming/bitcount.html#leading-0bits */
        /* sudoku3.cppでもこれを使いたかったが、これをやったらかえって遅くなったのでやめた */
        subsub();
        EAX ^= board[i - 1]
    } while (EAX != 0);
    board[i - 1] = 0;
    i--;
fin:
    return;
}

なお、case80だけは処理が少し違っています。というのは、case80の場合、選択肢は0個か1個の
場合しかなく、1個の場合はその数字で盤を埋めることで解が一つ求まると確信できるからです。
つまり EAX & (-EAX) みたいな計算をする必要がないわけです。その処理を省略することで、
高速化を狙っています。

(4)

C++では、extern "C" な関数からは例外が使えないとのことだったので（言われてみれば当然！）、
例外をやめてsetjmp/longjmpに書き換えています。しかし、そもそもC++でlongjmpを使うのは危険な
ことです（と教えてもらいました）。なぜなら、longjmpだと、呼ばれるべきデストラクタが
呼ばれないことが起こりうるからです（まあだからこそ例外を使うべきなのですが）。

しかし今回の例に限れば、longjmpを使っても平気なはずです。というのはデストラクタが必要に
なりそうな処理をsetjmp以降で行っていないからです。

将来このプログラムを拡張していこうとすれば、上記の制約を気にしなければいけないという問題が
あるので良いプログラムであるとは言えませんが、拡張せずにこのクラスを上位ルーチンから使う
だけなら問題なく使えると思います。

ということで安易にlongjmpに逃げた私を許してください。


